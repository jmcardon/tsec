package tsec.build

import scala.collection.JavaConverters._

object GenSodium extends App {

  val FormatConfig = {
    import org.scalafmt.config._
    ScalafmtConfig.intellij.copy(
      align = Align.none,
      newlines = ScalafmtConfig.intellij.newlines.copy(
        alwaysBeforeTopLevelStatements = true,
      )
    )
  }

  import java.nio.charset._
  import javax.lang.model.`type`.TypeKind

  import com.sun.source.{tree => jtree}

  val jMethods: Seq[jtree.MethodTree] = {
    import com.sun.tools.javac._
    import tree.{JCTree => tree}

    import scala.io._

    val source = Source
      .fromFile("tsec-libsodium/jni/Sodium.java") // looking here b/c param names not in SodiumJNI
      .mkString
    val ctx = new util.Context()
    new file.JavacFileManager(ctx, true, StandardCharsets.UTF_8)
    util.Options.instance(ctx).put(com.sun.tools.javac.main.Option.PARAMETERS, "true")
    val parse = parser.ParserFactory
      .instance(ctx)
      .newParser(source, false, false, false)
    val unit = parse.parseCompilationUnit()
    val clasz = unit.getTypeDecls.asScala.collectFirst {
      case decl: tree.JCClassDecl if decl.name.toString == "Sodium" => decl
    }.getOrElse(sys.error("could not find Sodium class"))

    clasz.defs.asScala.collect {
      case decl: tree.JCMethodDecl => decl
    }
  }

  import scala.meta._

  def transType(jt: jtree.Tree): Type = jt match {
    case prim: jtree.PrimitiveTypeTree => prim.getPrimitiveTypeKind match {
      case TypeKind.BOOLEAN => t"Boolean"
      case TypeKind.BYTE    => t"Byte"
      case TypeKind.SHORT   => t"Short"
      case TypeKind.INT     => t"Int"
      case TypeKind.LONG    => t"Long"
      case TypeKind.CHAR    => t"Char"
      case TypeKind.FLOAT   => t"Float"
      case TypeKind.DOUBLE  => t"Double"
      case TypeKind.VOID    => t"Unit"
      case other            => sys.error(s"Unsupported primitive type kind $other")
    }
    case arr: jtree.ArrayTypeTree => t"Array[${transType(arr.getType)}]"
  }

  val sMethods = jMethods.map { jm =>
    val params: List[Term.Param] = jm.getParameters.asScala.map { jp =>
      val name = Term.Name(jp.getName.toString)
      val tpe = transType(jp.getType)
      Term.Param(mods = Nil, name = name, decltpe = Some(tpe), default = None)
    }.toList
    val name = Term.Name(jm.getName.toString)
    val tpe = transType(jm.getReturnType)
    val args = params.map { p => Term.Name(p.name.value) }
    val rhs = q"SodiumJNI.$name(..$args)"
    Defn.Def(
      mods = Mod.Final() :: Nil,
      name = name,
      tparams = Nil,
      paramss = List(params),
      decltpe = Some(tpe),
      body = rhs
    )
  }.sortBy(_.name.value).toList

  val noSelfType = Term.Param(Nil, Name.Anonymous(), None, None)

  val clsDef = Defn.Class(
    mods = Mod.Abstract() :: Mod.Protected(within = Term.Name("tsec")):: Nil,
    name = Type.Name("ScalaSodium0"),
    tparams = Nil,
    ctor = Ctor.Primary(Mod.Private(within = Term.Name("tsec")) :: Nil, name = Ctor.Name("ScalaSodium0"), paramss = Nil),
    templ = Template(early = Nil, parents = Nil, self = noSelfType, Some(sMethods))
  )

  val warning =
    s"""/* !!! GENERATED CODE: DO NOT EDIT !!!                                                       */
       |/* This file is generated by project/boiler/gensodium.scala from tsec-libsodium/jni/sodium.i */
       |/* Timestamp: ${java.time.Instant.now.toString}                                                       */
       |
     """.stripMargin

  val pkg = Pkg(q"tsec.jni", clsDef :: Nil)

  val src = org.scalafmt.Scalafmt.format(warning + pkg.toString, style = FormatConfig).get

  import java.io._

  new FileOutputStream(new File("tsec-libsodium/src/main/scala/tsec/jni/ScalaSodium0.scala"))
    .write(src.getBytes(StandardCharsets.UTF_8))
}
